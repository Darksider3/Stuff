//
// Created by darksider3 on 22.01.21.
//

#ifndef POCO_FILE_HASHER_STRINGFORMAT_HPP
#define POCO_FILE_HASHER_STRINGFORMAT_HPP

#include "Poco/Format.h"
#include "Print/Format/AbstractOutputFormatter.hpp"
#include "Print/Format/BSDFormat.hpp"
#include "Print/Format/CSVFormat.hpp"
#include "Print/Format/PrintFormat.hpp"
#include "common.hpp"
#include <Poco/DigestEngine.h>
#include <Poco/File.h>
#include <string>

namespace Formatting {
/**
 * @brief Formatting function for hashes generated by our little main logic function, which mimics the sha\*sum programs
 *
 * @param  const std::vector<unsigned char>& digest          Digest generated by the engine(`Poco::DigestEngine B.digest()`) to format
 * @param  const Poco::File&                 F               Fileobject used for hashing(here just used to get the path)
 * @param  const bool                        AddMethod       Weither we append the method's name alongside the Files Path and Name
 * @param  const std::string_view            Method_Name     Method names then used beforehand
 *
 * @return std::string Formatted Hash that mimics the  behaivour of sha1sum, sha256sum, md5sum etc. (HexDigest, followed by 2 spaces, followed by Path and newline)
 */
std::string FormatHash(const std::vector<unsigned char>& digest, Poco::File& F, Formatting::AbstractOutputFormatter<BSDFormat>* fmt, const bool AddMethod = false, std::string_view Method_Name = "null")
{

    std::string return_str;
    std::string method { Method_Name };
    assert(F.exists() && "File must exist to hash it!");
    assert(!method.empty() && "Method name should be an optional parameter and thus needs sadly content...");
    fmt->reinit(digest, F, method, return_str);

    return fmt->FormatHash();
}

/**
 * @brief Formatting function for hashes generated by our little main logic function, which mimics the sha\*sum programs
 *
 * @param  const std::vector<unsigned char>& digest          Digest generated by the engine(`Poco::DigestEngine B.digest()`) to format
 * @param  const Poco::File&                 F               Fileobject used for hashing(here just used to get the path)
 * @param  const bool                        AddMethod       Weither we append the method's name alongside the Files Path and Name
 * @param  const std::string_view            Method_Name     Method names then used beforehand
 *
 * @return std::string Formatted Hash that mimics the  behaivour of sha1sum, sha256sum, md5sum etc. (HexDigest, followed by 2 spaces, followed by Path and newline)
 */
std::string FormatHash(const std::vector<unsigned char>& digest, Poco::File& F, Formatting::AbstractOutputFormatter<PrintFormat>* fmt, const bool AddMethod = false, std::string_view Method_Name = "null")
{

    std::string return_str;
    std::string method { Method_Name };
    assert(F.exists() && "File must exist to hash it!");
    assert(!method.empty() && "Method name should be an optional parameter and thus needs sadly content...");
    fmt->reinit(digest, F, method, return_str);
    assert(fmt->good() && "Everything should actually be set before we do anything, lol."); // asserts all stored pointers...
    fmt->setOption(AddMethod, "AddHashToFormat");

    return fmt->FormatHash();
}

// CSV Overload
[[unused]] std::string FormatHash(const std::vector<unsigned char>& digest, Poco::File& F, Formatting::AbstractOutputFormatter<CSVFormat>* fmt, const bool /*AddMethod*/ = false, std::string_view Method_Name = "null")
{
    std::string return_str;
    std::string method { Method_Name };
    fmt->reinit(digest, F, method, return_str);

    return fmt->FormatHash();
}

/**
 * @brief Compares Hash1 with Hash1, currently without considerating the filename
 *
 * @param const std::string& HashStr1 First Hash
 * @param const std::string& HashStr2 Second hash to compare against
 *
 * @return bool If equal, `true`. Otherwhise `false`.
 */
bool CompareHash(const std::string& HashStr1, const std::string& HashStr2)
{
    // bc458c17dc8eefd118d81133c2be26a2  ./CMakeCache.txt
    // bc458c17dc8eefd118d81133c2be26a2  ./CMakeCache.txt; MD5.

    assert(!HashStr1.empty() && "Should not be empty!");
    assert(!HashStr2.empty() && "Should not be empty!");

    std::string delimiter = "  ";
    std::string hash1 = HashStr1.substr(0, HashStr1.find(delimiter));
    std::string hash2 = HashStr2.substr(0, HashStr2.find(delimiter));

    assert(!hash1.empty() && "If correctly formatted, this shouldnt ever be empty!");
    assert(!hash2.empty() && "If correctly formatted, this shouldnt ever be empty!");

    return hash1 == hash2;
}

}
#endif //POCO_FILE_HASHER_STRINGFORMAT_HPP
